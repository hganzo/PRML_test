### GaussianMixtureModel ###

# EM algo 
# 

module GaussianMixtureModel
#Pkg.add("Distributions")
using Distributions
using PDMats

# global structure
export GW, BGMM, Gauss, GMM

# global function 
export sample_GMM, sample_data

struct GW
    # Parameters of Gauss Wisahrt distribution
    beta::Float64
    m::Vector{Float64}
    nu::Float64
    W::Matrix{Float64}
end

struct BGMM
    # Parameters of Bayesian Gaussian Mixture Model 
    D::Int  # Dimension of data
    K::Int  # Mixted Components
    alpha::Vector{Float64} # related with components weight (Dirichlet parameter)
    Wcmp::Vector{GW} #Wishart parameters struct
end

struct Gauss
    # Parameters of Gauss Distribution
    mu::Vector{Float64} # Gassian mean
    Lambda::Matrix{Float64} # Gaussian covariance
end

struct GMM
    # Parameters of Gauss Mixture Model
    D::Int # data dimension
    K::Int # N components
    phi::Vector{Float64} # components parameter
    Gcmp::Vector{Gauss} # Gaussian parameter struct
end


# Wishart:
# D dim Gaussian prior (Lamba known)
# MvNormal:
# D dim Gaussian prior (mu known)


function sample_GMM(bgmm::BGMM)
# sampling gaussian parameters
#    srand(1)
    cmp = Vector{Gauss}()
    for c in bgmm.Wcmp
        Lambda = rand(Wishart(c.nu, PDMats.PDMat(Symmetric(c.W))))
        mu = rand(MvNormal(c.m, PDMats.PDMat(Symmetric(inv(c.beta*Lambda)))))
        push!(cmp,Gauss(mu,Lambda))
    end
    phi = rand(Dirichlet(bgmm.alpha)) 
    return GMM(bgmm.D, bgmm.K, phi, cmp)
end

function sample_data(gmm::GMM, N::Int)
# sampling the MvNormal data
#    srand(1)
    X = zeros(gmm.D, N) # data
    S = categorical_sample(gmm.phi, N) # X components
    for n in 1 : N
        k = indmax(S[:, n])
        X[:,n] = rand(MvNormal(gmm.Gcmp[k].mu, PDMats.PDMat(Symmetric(inv(gmm.Gcmp[k].Lambda)))))
        end
    return X, S
end


# The case of 1 dim (N is blank)
categorical_sample(p::Vector{Float64}) = categorical_sample(p, 1)[:,1]

function categorical_sample(p::Vector{Float64}, N::Int)
    K = length(p)
    S = zeros(K, N)
    S_tmp = rand(Categorical(p), N)
    for k in 1 : K
        S[k,find(S_tmp.==k)] = 1
    end
    return S
end



# tools
function init_S(X::Matrix{Float64}, bgmm:BGMM)
    N = size(X,2)
    K = bgmm.K
    S = categorical_sample(one(K)/K, N)
    return S
end

function add_stats(prior_bgmm:BGMM, X::Matrix{Float64}, S:Matrix{Float64})
    D = bgmm.D
    K = bgmm.K
    sum_S = sum(S, 2)
    alpha = [bgmm.alpha[k] + sum_S[k] for k in 1 : K]
    cmp = Vector{GW}()
    
    for k in 1 : K
        beta = bgmm.cmp[k].beta + sum_S[k]
        m = (1.0/beta)*(vec(X*S[[k],:]) + bgmm.cmp[k].beta*bgmm.cmp[k].m )
        nu = bgmm.cmp[k].nu + sum_S[k]
        W = inv(X*diagm(S[k,:])*X
                        - beta*m*m
                        + bgmm.cmp[k].beta*bgmm.cmp[k].m*bgmm.cmp[k].m
                        + inv(bgmm.cmp[k].W))
        push!(cmp,GW(beta,m,nu,W))

    end
    return BGMM(D, K, alpha, cmp)
end

#### used for Gibbs sampling
function sample_S_GS(gmm::GMM, X::Matrix{Float64})
    D, N = size(X) # dimension, data records
    K = gmm.K      # N cluster 
    S = zeros(K, N)
    tmp = [0.5*logdet(gmm.cmp[k].Lambda) + log.(gmm.phi[k]) for k in 1 : K]
    for n in 1 : N
            tmp_ln_phi = [-0.5*trace(gmm.cmp[k].Lambda*(X[:,n] - gmm.cmp[k].mu)*(X[:,n] - gmm.cmp[k].mu)) + tmp[k] for k in 1 : K]
            tmp_ln_phi = tmp_ln_phi - logsumexp(tmp_ln_phi)
            S[:,n] = categorical_sample(exp.(tmp_ln_phi))




#### Gibbs sampling

function learn_GS(X::Matrix{Float64}, prior_bgmm::BGMM, max_iter::Int)
# init
    # init the parameter for components
    S = init_S(X, prior_bgmm)
    # init bgmm parameter
    bgmm = add_stats(prior_bgmm, X, S)
    # init VB ?
    VB = NaN * zeros(max_iter)
    
    for i in 1 : max_iter
        # sample parameter
        gmm = sample_GMM(bgmm)
        # sample latest variables
        S = sample_S_GS(gmm, X)         # not avail
        # update current model
        # bgmm = add_stats(prior_bgmm, X, S) # not avail
        # calc VB ? ELBO 変分下限
        # VB[i] = calc_ELBO(X, prior_bgmm, bgmm) # not avail
    end
    return S, bgmm, VB
end




